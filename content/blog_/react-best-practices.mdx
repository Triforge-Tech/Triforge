---
title: React Best Practices for 2024
publishedAt: 2024-01-20
excerpt: Modern patterns and practices for building maintainable React applications with hooks, TypeScript, and performance optimization.
coverImage: https://images.unsplash.com/photo-1633356122102-3fe601e05bd2?w=1200&h=630&fit=crop
author: jane-doe
tags:
  - React
  - JavaScript
  - Web Development
featured: true
seo:
  metaTitle: React Best Practices 2024 - Modern Development Guide
  metaDescription: Learn the latest React best practices including hooks patterns, TypeScript integration, performance optimization, and clean code principles.
  canonicalUrl: https://triforge.net/blog/react-best-practices
---

React has evolved significantly, and with it, the best practices for building applications. This guide covers modern patterns that will help you write cleaner, more maintainable React code in 2024.

## Component Structure

Organize your components with a consistent structure:

```tsx
import { useState, useEffect } from 'react'
import { useQuery } from '@tanstack/react-query'

// Types
interface UserProfileProps {
  userId: string
  onUpdate?: (user: User) => void
}

// Component
export default function UserProfile({ userId, onUpdate }: UserProfileProps) {
  // Hooks
  const [isEditing, setIsEditing] = useState(false)
  const { data: user, isLoading } = useQuery(['user', userId], () => fetchUser(userId))

  // Effects
  useEffect(() => {
    if (user) {
      document.title = `${user.name} - Profile`
    }
  }, [user])

  // Event handlers
  const handleEdit = () => setIsEditing(true)
  const handleSave = async (data: User) => {
    await updateUser(data)
    setIsEditing(false)
    onUpdate?.(data)
  }

  // Early returns
  if (isLoading) return <LoadingSpinner />
  if (!user) return <ErrorMessage />

  // Render
  return (
    <div className="user-profile">
      {isEditing ? (
        <UserEditForm user={user} onSave={handleSave} />
      ) : (
        <UserDisplay user={user} onEdit={handleEdit} />
      )}
    </div>
  )
}
```

## Custom Hooks

Extract reusable logic into custom hooks:

```tsx
// useDebounce hook
function useDebounce<T>(value: T, delay: number = 500): T {
  const [debouncedValue, setDebouncedValue] = useState<T>(value)

  useEffect(() => {
    const handler = setTimeout(() => {
      setDebouncedValue(value)
    }, delay)

    return () => {
      clearTimeout(handler)
    }
  }, [value, delay])

  return debouncedValue
}

// Usage
function SearchComponent() {
  const [search, setSearch] = useState('')
  const debouncedSearch = useDebounce(search, 300)

  const { data } = useQuery(['search', debouncedSearch], () => searchAPI(debouncedSearch), {
    enabled: !!debouncedSearch,
  })

  return <input value={search} onChange={(e) => setSearch(e.target.value)} />
}
```

## State Management

Use the right tool for the job:

### Local State (useState)

For component-specific state:

```tsx
function Counter() {
  const [count, setCount] = useState(0)

  return <button onClick={() => setCount((c) => c + 1)}>Count: {count}</button>
}
```

### Context API

For app-wide state that doesn't change often:

```tsx
// theme-context.tsx
import { createContext, useContext, useState, ReactNode } from 'react'

interface ThemeContextType {
  theme: 'light' | 'dark'
  toggleTheme: () => void
}

const ThemeContext = createContext<ThemeContextType | undefined>(undefined)

export function ThemeProvider({ children }: { children: ReactNode }) {
  const [theme, setTheme] = useState<'light' | 'dark'>('light')

  const toggleTheme = () => {
    setTheme((t) => (t === 'light' ? 'dark' : 'light'))
  }

  return <ThemeContext.Provider value={{ theme, toggleTheme }}>{children}</ThemeContext.Provider>
}

export function useTheme() {
  const context = useContext(ThemeContext)
  if (!context) {
    throw new Error('useTheme must be used within ThemeProvider')
  }
  return context
}
```

### Zustand/Jotai

For complex global state:

```tsx
import create from 'zustand'

interface CartStore {
  items: CartItem[]
  addItem: (item: CartItem) => void
  removeItem: (id: string) => void
  clearCart: () => void
}

export const useCartStore = create<CartStore>((set) => ({
  items: [],
  addItem: (item) =>
    set((state) => ({
      items: [...state.items, item],
    })),
  removeItem: (id) =>
    set((state) => ({
      items: state.items.filter((i) => i.id !== id),
    })),
  clearCart: () => set({ items: [] }),
}))

// Usage
function Cart() {
  const items = useCartStore((state) => state.items)
  const removeItem = useCartStore((state) => state.removeItem)

  return (
    <div>
      {items.map((item) => (
        <CartItem key={item.id} {...item} onRemove={removeItem} />
      ))}
    </div>
  )
}
```

## Performance Optimization

### Memoization

Use `memo`, `useMemo`, and `useCallback` wisely:

```tsx
import { memo, useMemo, useCallback } from 'react'

// Memoize expensive components
const ExpensiveList = memo(function ExpensiveList({ items }: { items: Item[] }) {
  return (
    <ul>
      {items.map((item) => (
        <li key={item.id}>{item.name}</li>
      ))}
    </ul>
  )
})

function ParentComponent() {
  const [filter, setFilter] = useState('')
  const [items, setItems] = useState<Item[]>([])

  // Memoize expensive computations
  const filteredItems = useMemo(() => {
    return items.filter((item) => item.name.toLowerCase().includes(filter.toLowerCase()))
  }, [items, filter])

  // Memoize callbacks passed to child components
  const handleItemClick = useCallback((id: string) => {
    console.log('Clicked:', id)
  }, [])

  return (
    <>
      <input value={filter} onChange={(e) => setFilter(e.target.value)} />
      <ExpensiveList items={filteredItems} />
    </>
  )
}
```

### Code Splitting

Load components on demand:

```tsx
import { lazy, Suspense } from 'react'

const HeavyChart = lazy(() => import('./components/HeavyChart'))

function Dashboard() {
  return (
    <div>
      <h1>Dashboard</h1>
      <Suspense fallback={<ChartSkeleton />}>
        <HeavyChart data={chartData} />
      </Suspense>
    </div>
  )
}
```

## Error Handling

Implement error boundaries:

```tsx
import { Component, ReactNode } from 'react'

interface Props {
  children: ReactNode
  fallback?: ReactNode
}

interface State {
  hasError: boolean
  error?: Error
}

class ErrorBoundary extends Component<Props, State> {
  constructor(props: Props) {
    super(props)
    this.state = { hasError: false }
  }

  static getDerivedStateFromError(error: Error): State {
    return { hasError: true, error }
  }

  componentDidCatch(error: Error, errorInfo: any) {
    console.error('Error caught by boundary:', error, errorInfo)
    // Log to error reporting service
  }

  render() {
    if (this.state.hasError) {
      return (
        this.props.fallback || (
          <div className="error-container">
            <h2>Something went wrong</h2>
            <p>{this.state.error?.message}</p>
            <button onClick={() => this.setState({ hasError: false })}>Try again</button>
          </div>
        )
      )
    }

    return this.props.children
  }
}

// Usage
function App() {
  return (
    <ErrorBoundary fallback={<ErrorPage />}>
      <MyApp />
    </ErrorBoundary>
  )
}
```

## TypeScript Integration

Leverage TypeScript for better DX:

```tsx
// Define prop types
interface ButtonProps extends React.ButtonHTMLAttributes<HTMLButtonElement> {
  variant?: 'primary' | 'secondary' | 'danger'
  size?: 'sm' | 'md' | 'lg'
  isLoading?: boolean
}

// Use type inference
export function Button({
  variant = 'primary',
  size = 'md',
  isLoading,
  children,
  className,
  ...props
}: ButtonProps) {
  return (
    <button
      className={cn('btn', `btn-${variant}`, `btn-${size}`, className)}
      disabled={isLoading}
      {...props}
    >
      {isLoading ? <Spinner /> : children}
    </button>
  )
}

// Generic components
interface ListProps<T> {
  items: T[]
  renderItem: (item: T) => ReactNode
  keyExtractor: (item: T) => string
}

function List<T>({ items, renderItem, keyExtractor }: ListProps<T>) {
  return (
    <ul>
      {items.map((item) => (
        <li key={keyExtractor(item)}>{renderItem(item)}</li>
      ))}
    </ul>
  )
}
```

## Testing

Write maintainable tests:

```tsx
import { render, screen, fireEvent } from '@testing-library/react'
import userEvent from '@testing-library/user-event'
import { Counter } from './Counter'

describe('Counter', () => {
  it('renders initial count', () => {
    render(<Counter initialCount={5} />)
    expect(screen.getByText(/count: 5/i)).toBeInTheDocument()
  })

  it('increments count on button click', async () => {
    const user = userEvent.setup()
    render(<Counter initialCount={0} />)

    const button = screen.getByRole('button', { name: /increment/i })
    await user.click(button)

    expect(screen.getByText(/count: 1/i)).toBeInTheDocument()
  })

  it('calls onCountChange callback', async () => {
    const handleChange = jest.fn()
    const user = userEvent.setup()
    render(<Counter initialCount={0} onCountChange={handleChange} />)

    const button = screen.getByRole('button', { name: /increment/i })
    await user.click(button)

    expect(handleChange).toHaveBeenCalledWith(1)
  })
})
```

## Accessibility

Make your apps accessible:

```tsx
function Modal({ isOpen, onClose, title, children }: ModalProps) {
  useEffect(() => {
    if (isOpen) {
      // Trap focus
      const previouslyFocused = document.activeElement as HTMLElement

      return () => {
        previouslyFocused?.focus()
      }
    }
  }, [isOpen])

  if (!isOpen) return null

  return (
    <div
      role="dialog"
      aria-modal="true"
      aria-labelledby="modal-title"
      className="modal-overlay"
      onClick={onClose}
    >
      <div className="modal-content" onClick={(e) => e.stopPropagation()}>
        <h2 id="modal-title">{title}</h2>
        <button aria-label="Close modal" onClick={onClose}>
          Ã—
        </button>
        {children}
      </div>
    </div>
  )
}
```

## Conclusion

These best practices will help you build React applications that are:

- **Maintainable**: Clear structure and patterns
- **Performant**: Optimized rendering and code splitting
- **Type-safe**: TypeScript integration
- **Testable**: Well-structured components
- **Accessible**: Following WCAG guidelines

Keep learning, and stay updated with the React ecosystem as it continues to evolve!
